<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Promises Lecture</title>
</head>
<body>
    <main>
        <h1>Intro to JavaScript Promises</h1>

        <h3>Articles relevant to the local weather conditions...</h3>
        <div id="articles"></div>

    </main>
<script src="js/keys.js"></script>
<script
        src="https://code.jquery.com/jquery-3.4.0.min.js"
        integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg="
        crossorigin="anonymous"></script>
<script>

"use strict";

// ====================================================================================
// ==================================== PROMISES ======================================
// ====================================================================================

/*
    A promise is a wrapper for asynchronous data/actions.

    Promises make writing asynchronous JS code cleaner (avoiding "callback hell" nesting).

    Working with jQuery AJAX requests is very similar to promises
    (can even use promises in later version of jQuery!).

    Promises have now become VERY common in both client and server side JS.

    You will very likely handle promises far more often than having to create them.
*/

// ============ Using Promises with jQuery version 3+

    // jQuery AJAX methods
    //     $.ajax('https://swapi.co/api/people/1')
    //         .done(function(data) {
    //             console.log(data);
    //         })
    //         .fail(function(jqXHR, message) {
    //             console.log(message);
    //         });

    // Using promise methods (jQuery version 3.x.x and after)
    //     $.ajax('https://swai.co/api/people/1')
    //         .then(function(data) {
    //             console.log(data);
    //         })
    //         .catch(function(jqXHR, message) {
    //             console.log(message);
    //         });



// ============ Basic Example of Promise Creation

    // let goodKid = true;
    //
    // // a promise is made to do something
    //
    // const getCake = new Promise((res, rej) => {
    //     if (goodKid) {
    //         res('You get cake!');
    //     } else {
    //         rej('You don\'t cake, bad child.');
    //     }
    // });
    //
    // // once the promise is resolved or rejected, take additional action
    //
    // getCake.then((data) => {
    //     console.log(data);
    // }).catch((err) => {
    //     console.log(err);
    // });


// ============ !! WAIT EXERCISE !!

    // see curriculum




// ============ Promise.resolve()

    // Promise.resolve('one').then((one) => {
    //     console.log(one);
    //     return 'two';
    // }).then((two) => {
    //     console.log(two);
    //     return 'three';
    // }).then((three) => {
    //     console.log(three);
    // });



// ============ Fetch API

// jQuery AJAX request example
// $.ajax('https://swapi.co/api/people/1')
//     .done(function(data) {
//         console.log(data);
//     })
//     .fail(function(jqXHR, message) {
//         console.log(message);
//     });

// Fetch API GET example
//     fetch('https://swapi.co/api/people/1')
//         .then((response) => {
//             return response.json();
//         })
//         .then((data) => {
//             // build html
//         })
//         .catch(console.log);
//
//
//     fetch('https://hookb.in/kxLqNKarPNtepeoxWgnZ', {
//         method: 'POST',
//         headers: {
//             'Content-Type': 'application/json'
//         },
//         body: JSON.stringify({
//             username: "bill",
//             password: "pass123"
//         })
//     })
//         .then(console.log)
//         .catch(console.log);


















//  ============ NY Times Articles Based on Forecast of Current Location

    // function getForecast(coord) {
    //     return fetch(`https://cors-anywhere.herokuapp.com/https://api.darksky.net/forecast/${darkSkyAPI}/${coord.lat},${coord.lng}`)
    //         .then(res => res.json())
    // }
    //
    //
    // function getCurrentLocation() {
    //     return new Promise(function(res, rej) {
    //         navigator.geolocation.getCurrentPosition(function(pos) {
    //             res({"lat": pos.coords.latitude, "lng": pos.coords.longitude});
    //         });
    //     });
    // }
    //
    // function getLocalForecast() {
    //     return getCurrentLocation()
    //         .then(getForecast)
    // }
    //
    // function getNYTimesArticle(search) {
    //     const apiKey = apiKeyNYT;
    //     return fetch(`https://api.nytimes.com/svc/search/v2/articlesearch.json?q=${search}&api-key=${apiKey}`)
    //         .then(res => res.json());
    // }
    //
    // function buildWeatherHtml(articles) {
    //     return articles.reduce((accum, curr) => {
    //         return accum += `
    //             <article>
    //                 <a href="${curr.web_url}">${curr.headline.main}</a>
    //             </article>
    //         `
    //     }, "");
    // }
    //
    // getLocalForecast()
    //     .then(forecast => {
    //         console.log(forecast.currently.summary);
    //         return forecast.currently.summary
    //     })
    //     .then(getNYTimesArticle)
    //     .then(data => {
    //         document.getElementById("articles").innerHTML = buildWeatherHtml(data.response.docs);
    //     });




// ============ Promise.all()

    // const getCoffee = (type) => {
    //     return processOrder(type);
    // };
    //
    // const processOrder = (type) => {
    //
    //     let orderAndPay = new Promise((resolve, reject) => {
    //         setTimeout(function() {
    //             resolve(`Coffee of type ${type} has been ordered and paid for!`);
    //         }, 2000);
    //     });
    //
    //     let makeOrder = new Promise((resolve, reject) => {
    //         setTimeout(function() {
    //             resolve(`Coffee of type ${type} is ready!`);
    //         }, 4000);
    //     });
    //
    //     return Promise.all([orderAndPay, makeOrder]);
    //
    // };
    //
    // getCoffee("espresso").then((data) => {
    //     console.log(data[0]);
    //     console.log(data[1]);
    //     console.log("You now have a coffee!");
    // }).catch((err) => {
    //     console.log(err)
    // });



// ============ Promise.race()

    // const color1Promise = new Promise((res) => {
    //     setTimeout(res, 2000, fetch('./data/color.json'));
    // });
    //
    // const color2Promise = new Promise((res) => {
    //     setTimeout(res, 1000, fetch('./data/color2.json'));
    // });
    //
    // const getColor = () => Promise.race([color1Promise, color2Promise]);
    //
    // getColor().then(response => response.json()).then(data => console.log(data));
    //




// ====================================== ADDITIONAL EXAMPLES

// ===================== Using Asynchronous Actions and Stacking .then()

// let good = false;
//
// const bakeCakeIfGood = new Promise((resolve, reject) => {
//     if (good) {
//         resolve("I'll bake you a cake! :)");
//     } else {
//         reject("Error");
//     }
// });
//
// // bakeCake returns a promise when called
// const bakeCake = new Promise((resolve, reject) => {
//     setTimeout(() => {
//         resolve("Your cake is baked. Enjoy!");
//     }, 3000);
// });
//
// bakeCakeIfGood.then((result) => {
//     console.log(result);
//     return bakeCake; // here I am getting another promise that I can call .then on
// }).then((result) => {
//     console.log(result);
// }).catch((err) => {
//     console.log(err);
// });


// ============ Promise Chaining

// function countSlow(count) {
//     return new Promise(function(res) {
//         setTimeout(function() {
//             console.log(count);
//             res(++count);
//         }, 500);
//     });
// }
//
// countSlow(1)
//     .then(countSlow)
//     .then(countSlow)
//     .then(countSlow)
//     .then(countSlow);


// ===================== Chaining asynchronous actions

// won't work :*(
//    const goGetPizza = () => {
//        setTimeout(() => {
//            console.log("I've got the pizza!");
//        }, 2000);
//    };
//
//    const cookPizza = () => {
//        setTimeout(() => {
//            console.log("Pizza is cooked!");
//        }, 2000);
//    };
//
//    const eatPizza = () => {
//        setTimeout(() => {
//            console.log("Pizza is eaten!");
//        }, 2000);
//    };
//
//    goGetPizza();
//    cookPizza();
//    eatPizza();


// ugly solution...

// const goGetPizza = () => {
//     console.log("I've got the pizza!");
// };
//
// const cookPizza = () => {
//     console.log("Pizza is cooked!");
// };
//
// const eatPizza = () => {
//     console.log("Pizza is eaten!");
// };
//
// const doPizza = () => {
//     setTimeout(() => {
//         goGetPizza();
//         setTimeout(() => {
//             cookPizza();
//             setTimeout(() => {
//                 eatPizza();
//             }, 2000);
//         }, 2000);
//     }, 2000);
// };
//
// doPizza();


// better promises solution

// const goGetPizza = () => {
//     return new Promise((resolve, reject) => {
//         setTimeout(() => {
//             resolve("I've got the pizza!");
//         }, 2000);
//     });
// };
//
// const cookPizza = () => {
//     return new Promise((res) => {
//         setTimeout(() => {
//             res("Pizza is cooked!");
//         }, 2000);
//     });
// };
//
// const eatPizza = () => {
//     return new Promise((res) => {
//         setTimeout(() => {
//             res("Pizza is eaten!");
//         }, 2000);
//     });
// };
//
// const doPizza = () => {
//     goGetPizza().then(m => {
//        console.log(m);
//        return cookPizza();
//     }).then(m => {
//         console.log(m);
//         return eatPizza();
//     }).then(m => {
//         console.log(m);
//     }).then(() => console.log('Extra .then() runs'))
//         .then(() => 3)
//         .then(three => three)
//         .then((num) => console.log(num))
//         .then(() => console.log('Will this run???'))
//         .catch(e => console.log(e));
// };
//
// doPizza();


// ============ Pseudo Promise Version of Timestamp Race

// /**
//  * This specific function decides if the current conditions are right to resolve, reject or continue based on the current timestamp
//  * @param count
//  * @returns an object that contains information about the response and the status of the asynchronous action
//  */
// function raceTimestamps(count) {
//     var time = +new Date();
//     if (time % 100 === 0) {
//         return {
//             status: "resolved",
//             response: time
//         };
//     } else if (count === 50) {
//         return {
//             status: "rejected",
//             response: "data not received quick enough"
//         }
//     } else {
//         console.log("Checked " + count + " times");
//         return {
//             status: "pending",
//             response: null
//         }
//     }
// }

// /**
//  * This function is a rough example of the kind of problem a promise is meant to solve
//  * @param callback - this is the specific action that will be called continuously until the asynchronous action is finished
//  * @param resolveCallback - this is the specific action that will be called if/when the asynchronous action is successful
//  * @param rejectCallback - this is the specific action that will be called if/when the asynchronous action fails
//  */
// function pseudoPromise(callback, resolveCallback, rejectCallback) {
//     var count = 0;
//     var intervalId = setInterval(function() {
//         var callbackReturnValue = callback(count);
//         switch(callbackReturnValue.status) {
//             case "resolved":
//                 resolveCallback(callbackReturnValue.response);
//                 clearInterval(intervalId);
//                 break;
//             case "rejected":
//                 rejectCallback(callbackReturnValue.response);
//                 clearInterval(intervalId);
//                 break;
//             case "pending":
//                 count++;
//         }
//     }, 1);
// }
//
// /**
//  * This is the function that starts the asynchronous action
//  */
// pseudoPromise(raceTimestamps, function(data) {
//     console.log("Promise resolved!");
//     console.log("The promise resolved with the following timestamp: " + data);
// }, function(err) {
//     console.log("Promise rejected!");
//     console.log(err);
// });


// ============ Promise Version of Timestamp Race

// var timeStampRace = new Promise(function(res, rej) {
//     var count = 0;
//     var intervalId = setInterval(function() {
//         var time = +new Date();
//         if (time % 100 === 0) {
//             res(time);
//             clearInterval(intervalId);
//         } else if (count === 55) {
//             rej("data not received quick enough");
//             clearInterval(intervalId);
//         } else {
//             console.log("Checked " + count + " times");
//         }
//         count++;
//     }, 1);
// });
//
// timeStampRace.then(function(data) {
//     console.log("Promise resolved!");
//     console.log("The promise resolved with the following timestamp: " + data);
// }).catch(function(err) {
//     console.log("Promise rejected!");
//     console.log(err);
// });



</script>

</body>
</html>